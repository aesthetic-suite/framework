import React from 'react';

declare module 'aesthetic' {
  declare export type AestheticOptions = {
    defaultTheme: string,
    extendable: boolean,
    pure: boolean,
    stylesPropName: string,
    themePropName: string,
  };

  declare export type AtRuleCache<T> = { [rule: string]: T };

  declare export type ClassName = string;

  declare export type EventCallback = (() => void) |
    // @charset, @document, @import, @namespace, @page, @viewport
    ((statement: Statement, style: Style) => void) |
    // @font-face
    ((statement: Statement, style: FontFace[], fontFamily: string) => void) |
    // @keyframes
    ((statement: Statement, style: Keyframe, animationName: string) => void) |
    // @fallbacks
    ((declaration: StyleDeclaration, style: Fallbacks) => void) |
    // @media
    ((declaration: StyleDeclaration, style: MediaQuery, condition: string) => void) |
    // @supports
    ((declaration: StyleDeclaration, style: Support, condition: string) => void) |
    // property
    ((declaration: StyleDeclaration, style: Style, property: string) => void);

  declare export type Fallback = string;

  declare export type Fallbacks = { [property: string]: Fallback | Fallback[] };

  declare export type FontFace = {
    fontDisplay?: string,
    fontFamily: string,
    fontStyle?: string,
    fontWeight?: string | number,
    local?: string[],
    src: string | string[],
    unicodeRange?: string,
  };

  declare export type FontFaces = { [fontFamily: string]: FontFace[] };

  declare export type GlobalDeclaration = {
    '@charset'?: string,
    '@document'?: StyleDeclaration,
    '@font-face'?: FontFaces,
    '@import'?: string,
    '@keyframes'?: Keyframes,
    '@namespace'?: string,
    '@page'?: StyleDeclaration,
    '@viewport'?: StyleDeclaration,
  };

  declare export type HOCComponent = React$ComponentType<*>;

  declare export type HOCOptions = {
    extendable?: boolean,
    extendFrom?: string,
    pure?: boolean,
    styleName?: string,
    stylesPropName?: string,
    themePropName?: string,
  };

  declare export type HOCWrappedComponent = React$ComponentType<*>;

  declare export type Keyframe = {
    from?: StyleBlock,
    to?: StyleBlock,
    [percentage: string]: StyleBlock,
  };

  declare export type Keyframes = { [animationName: string]: Keyframe };

  declare export type MediaQuery = StyleBlock;

  declare export type MediaQueries = { [query: string]: MediaQuery };

  declare export type Statement = {
    ...GlobalDeclaration,
    [selector: string]: ClassName | StyleDeclaration,
  };

  declare export type Style = string | string[] | number | StyleBlock | StyleBlock[];

  declare export type StyleBlock = { [property: string]: Style };

  declare export type StyleCallback = (
    theme: ThemeDeclaration,
    prevStyles: Statement,
  ) => Statement;

  declare export type StyleDeclaration = {
    [property: string]: Style,
    '@fallbacks'?: Fallbacks,
    '@media'?: MediaQueries,
    '@supports'?: Supports,
  };

  declare export type Support = StyleBlock;

  declare export type Supports = { [feature: string]: Support };

  declare export type ThemeDeclaration = StyleBlock;

  declare export type StyleSheet = { [selector: string]: ClassName };

  declare export class Adapter {
    bypassNativeStyleSheet: boolean;
    native: boolean;
    options: Object;
    unifiedSyntax: boolean;

    constructor(options?: Object): this;
    transform<T: Object>(styleName: string, statement: T): StyleSheet;
  }

  declare export class ClassNameAdapter extends Adapter {}

  declare export class ThemeProvider extends React.Component<{
    children: React$Node,
    name: string,
  }> {}

  declare export default class Aesthetic {
    adapter: Adapter;
    cache: { [styleName: string]: StyleSheet };
    native: boolean;
    options: AestheticOptions;
    parents: { [childStyleName: string]: string };
    styles: { [styleName: string]: StyleCallback | Statement };
    themes: { [themeName: string]: ThemeDeclaration };

    constructor(adapter: Adapter, options?: Object): this;
    extendTheme(
      parentThemeName: string,
      themeName: string,
      theme?: ThemeDeclaration,
      globals?: GlobalDeclaration,
    ): this;
    getStyles(styleName: string, themeName?: string): Statement;
    getTheme(themeName?: string): ThemeDeclaration;
    registerTheme(
      themeName: string,
      theme?: ThemeDeclaration,
      globals?: GlobalDeclaration,
    ): this;
    setAdapter(adapter: Adapter): this;
    setStyles(
      styleName: string,
      statement: StyleCallback | Statement,
      extendFrom?: string,
    ): this;
    transformStyles(styleName: string, themeName?: string): StyleSheet;
    validateTransform(styleName: string, selector: string, value: ClassName): ClassName;
  }

  declare export function style(
    aesthetic: Aesthetic,
    styles: StyleCallback | Statement,
    options?: HOCOptions,
  ): (HOCWrappedComponent) => HOCComponent;

  declare export function createStyler(aesthetic: Aesthetic): style;

  declare export function classes(...values: *[]): string;
}

declare module 'aesthetic/unified' {
  import type {
    AtRuleCache,
    EventCallback,
    Fallbacks,
    FontFaces,
    Keyframes,
    MediaQueries,
    StyleDeclaration,
    Statement,
    Supports,
  } from 'aesthetic';

  declare export default class UnifiedSyntax {
    static LOCAL: string;
    static GLOBAL: string;
    events: { [eventName: string]: EventCallback };
    fallbacks: AtRuleCache<Fallbacks>;
    fontFaces: FontFaces;
    fontFacesCache: AtRuleCache<string[]>;
    keyframes: Keyframes;
    keyframesCache: AtRuleCache<string>;
    mediaQueries: AtRuleCache<MediaQueries>;
    supports: AtRuleCache<Supports>;

    convert(statement: Statement): Statement;
    convertDeclaration(selector: string, properties: StyleDeclaration): StyleDeclaration;
    emit(eventName: string, args: *[]): this;
    extract(selector: string, atRule: string, rules: *, fromScope: string): void;
    extractFallbacks(selector: string, properties: Fallbacks, fromScope: string): void;
    extractFontFaces(selector: string, rules: FontFaces, fromScope: string): void;
    extractKeyframes(selector: string, rules: Keyframes, fromScope: string): void;
    extractMediaQueries(selector: string, rules: MediaQueries, fromScope: string): void;
    extractSupports(selector: string, rules: Supports, fromScope: string): void;
    off(eventName: string): this;
    on(eventName: string, callback: EventCallback): this;
    resetGlobalCache(): void;
    resetLocalCache(): void;
  }
}
