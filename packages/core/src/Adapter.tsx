import uuid from 'uuid/v4';
import { isObject, stripClassPrefix } from 'aesthetic-utils';
import Aesthetic from './Aesthetic';
import CacheManager from './CacheManager';
import Sheet from './Sheet';
import StyleSheetManager from './StyleSheetManager';
import UnifiedSyntax from './UnifiedSyntax';
import { ClassName, SheetMap, StyleName, TransformOptions, ThemeName } from './types';
import { GLOBAL_STYLE_NAME } from './constants';

export default abstract class Adapter<
  NativeBlock extends object,
  ParsedBlock extends object | string = NativeBlock
> {
  aesthetic!: Aesthetic;

  syntax = new UnifiedSyntax<NativeBlock>();

  protected cacheManager = new CacheManager<SheetMap<ParsedBlock>>();

  protected sheetManager: StyleSheetManager | null = null;

  /**
   * Apply and inject global styles for the current theme.
   * This should only happen once!
   */
  applyGlobalStyles(baseOptions?: TransformOptions): this {
    // Templates may be generated by Webpack or something similar,
    // so set this programmatically based on the defined option.
    if (typeof document !== 'undefined') {
      document.documentElement.setAttribute('dir', this.aesthetic.options.rtl ? 'rtl' : 'ltr');
    }

    const options = this.prepareTransformOptions({
      ...baseOptions,
      global: true,
      name: GLOBAL_STYLE_NAME,
    });

    // Direction changes shouldn't regenerate global styles
    const cacheOptions = { ...options };

    delete cacheOptions.dir;

    const cache = this.cacheManager.get(GLOBAL_STYLE_NAME, cacheOptions);
    const globalSheet = this.aesthetic.getGlobalSheet(options.theme);

    if (cache || !globalSheet) {
      return this;
    }

    const parsedSheet = this.cacheManager.set(
      GLOBAL_STYLE_NAME,
      this.parseStyleSheet(
        this.syntax.convertGlobalSheet(globalSheet, options).toObject(),
        options,
      ),
      cacheOptions,
    );

    // Some adapters require the styles to be transformed to be flushed
    this.transformStyles(Object.values(parsedSheet), options);
    this.flushStyles(GLOBAL_STYLE_NAME);

    return this;
  }

  /**
   * Create and return a style sheet unique to an adapter.
   */
  createStyleSheet(styleName: StyleName, baseOptions?: TransformOptions): SheetMap<ParsedBlock> {
    const options = this.prepareTransformOptions(baseOptions);
    const cache = this.cacheManager.get(styleName, options);

    if (cache) {
      return cache;
    }

    // Apply global styles on first render
    this.applyGlobalStyles(baseOptions);

    const nativeSheet = this.syntax.convertStyleSheet(
      this.aesthetic.getStyleSheet(styleName, options.theme),
      {
        ...options,
        name: styleName,
      },
    );

    const parsedSheet = this.parseStyleSheet(nativeSheet.toObject(), options);

    return this.cacheManager.set(
      styleName,
      {
        ...parsedSheet,
        ...nativeSheet.classNames,
      } as SheetMap<ParsedBlock>,
      options,
    );
  }

  /**
   * Flush a target component's transformed styles and inject them into the DOM.
   * If no target defined, will flush all buffered styles.
   */
  flushStyles(styleName?: StyleName) {}

  /**
   * Return the standard cache manager.
   */
  getCacheManager(): CacheManager<SheetMap<ParsedBlock>> {
    return this.cacheManager;
  }

  /**
   * Return a native style sheet manager used for injecting CSS.
   */
  getStyleSheetManager(): StyleSheetManager {
    if (this.sheetManager) {
      return this.sheetManager;
    }

    this.sheetManager = new StyleSheetManager();

    return this.sheetManager;
  }

  /**
   * Return true if the style object is a parsed block and not a native block.
   */
  isParsedBlock(block: NativeBlock | ParsedBlock): block is ParsedBlock {
    return isObject(block);
  }

  /**
   * Parse an Aesthetic style sheet into an adapter native style sheet.
   */
  parseStyleSheet(
    styleSheet: SheetMap<NativeBlock>,
    options: Required<TransformOptions>,
  ): SheetMap<ParsedBlock> {
    // @ts-ignore Allow spread
    return { ...styleSheet };
  }

  /**
   * Purge and remove all styles from the DOM for the target component.
   * If no target defined, will purge all possible styles.
   */
  purgeStyles(styleName?: StyleName) {}

  /**
   * Reset and clear global styles for the defined theme.
   */
  resetGlobalStyles(prevTheme: ThemeName): this {
    this.purgeStyles(GLOBAL_STYLE_NAME);
    this.cacheManager.clear(unit => unit.global === true && unit.theme === prevTheme);

    return this;
  }

  /**
   * Transform the list of class names or style objects to a single class name.
   */
  transformStyles(
    styles: (undefined | false | null | ClassName | NativeBlock | ParsedBlock)[],
    baseOptions?: TransformOptions,
  ): ClassName {
    const options = this.prepareTransformOptions(baseOptions);
    const classNames: ClassName[] = [];
    const nativeBlocks: NativeBlock[] = [];
    const parsedBlocks: ParsedBlock[] = [];
    let inlineName = '';

    styles.forEach(style => {
      if (!style) {
        return;
      }

      if (typeof style === 'string') {
        classNames.push(
          ...String(style)
            .split(' ')
            .map(s => stripClassPrefix(s).trim()),
        );
      } else if (isObject(style)) {
        if (this.isParsedBlock(style)) {
          parsedBlocks.push(style);
        } else {
          nativeBlocks.push(style);
        }
      } else if (__DEV__) {
        throw new Error('Unsupported style type to transform.');
      }
    });

    // Convert native blocks to parsed blocks
    if (nativeBlocks.length > 0) {
      const nativeSheet: Sheet<NativeBlock> = new Sheet(options);
      let counter = 0;
      inlineName = uuid();

      nativeBlocks.forEach(block => {
        nativeSheet.addRuleset(nativeSheet.createRuleset(`inline-${counter}`).addProperties(block));
        counter += 1;
      });

      parsedBlocks.push(...Object.values(this.parseStyleSheet(nativeSheet.toObject(), options)));
    }

    // Transform parsed blocks to class names
    if (parsedBlocks.length > 0) {
      classNames.push(this.transformToClassName(parsedBlocks));
    }

    // Flush styles immediately since they're being rendered
    if (inlineName) {
      this.flushStyles(inlineName);
    }

    return classNames.join(' ').trim();
  }

  /**
   * Transform the compiled style objects into a class name.
   */
  abstract transformToClassName(styles: ParsedBlock[]): ClassName;

  /**
   * Return transform options with defaults applied.
   */
  protected prepareTransformOptions(options: TransformOptions = {}): Required<TransformOptions> {
    const dir = this.aesthetic.options.rtl ? 'rtl' : 'ltr';

    return {
      dir: options.dir || dir,
      global: options.global || false,
      name: options.name || '',
      theme: options.theme || this.aesthetic.options.theme,
    };
  }
}
