import deepMerge from 'extend';
import uuid from 'uuid/v4';
import { isObject, stripClassPrefix } from 'aesthetic-utils';
import CacheManager from './CacheManager';
import Sheet from './Sheet';
import StyleSheetManager from './StyleSheetManager';
import UnifiedSyntax from './UnifiedSyntax';
import { GLOBAL_STYLE_NAME } from './constants';
import {
  ClassName,
  TransformOptions,
  SheetMap,
  StyleName,
  StyleSheetFactory,
  ThemeName,
} from './types';

export default abstract class Adapter<
  Theme extends object,
  NativeBlock extends object,
  ParsedBlock extends object | string = NativeBlock
> {
  syntax = new UnifiedSyntax<NativeBlock>();

  protected sheetManager: StyleSheetManager | null = null;

  /**
   * Apply and inject global styles for the current theme.
   * This should only happen once!
   */
  applyGlobalStyles(baseOptions?: TransformOptions): this {
    // Templates may be generated by Webpack or something similar,
    // so set this programmatically based on the defined option.
    if (typeof document !== 'undefined') {
      document.documentElement.setAttribute('dir', this.options.rtl ? 'rtl' : 'ltr');
    }

    const options = this.getPreparedTransformOptions({
      ...baseOptions,
      global: true,
      name: GLOBAL_STYLE_NAME,
    });

    // Direction changes shouldn't regenerate global styles
    delete options.dir;

    const cache = this.cacheManager.get(GLOBAL_STYLE_NAME, options);
    const globalDef = this.globals[options.theme];

    if (cache || !globalDef) {
      return this;
    }

    const globalSheet = globalDef(this.getTheme(options.theme));
    const parsedSheet = this.cacheManager.set(
      GLOBAL_STYLE_NAME,
      this.parseStyleSheet(
        this.syntax.convertGlobalSheet(globalSheet, options).toObject(),
        GLOBAL_STYLE_NAME,
      ),
      options,
    );

    // Some adapters require the styles to be transformed to be flushed
    this.transformStyles(Object.values(parsedSheet), options);
    this.flushStyles(GLOBAL_STYLE_NAME);

    return this;
  }

  /**
   * Change the current theme to another registered theme.
   * This will purge all flushed global styles and regenerate new ones.
   */
  changeTheme(themeName: ThemeName): this {
    const oldTheme = this.options.theme;

    // Set theme as new option
    this.getTheme(themeName);
    this.options.theme = themeName;

    // Purge previous global styles
    this.purgeStyles(GLOBAL_STYLE_NAME);
    this.cacheManager.clear(unit => unit.global === true && unit.theme === oldTheme);

    // Generate new global styles
    this.applyGlobalStyles({ theme: themeName });

    return this;
  }

  /**
   * Create and return a style sheet unique to an adapter.
   */
  createStyleSheet(styleName: StyleName, baseOptions?: TransformOptions): SheetMap<ParsedBlock> {
    // Apply global styles on first render
    this.applyGlobalStyles(baseOptions);

    const nativeSheet = this.syntax.convertStyleSheet(
      this.getStyleSheet(styleName, options.theme),
      {
        ...options,
        name: styleName,
      },
    );

    const parsedSheet = this.parseStyleSheet(nativeSheet.toObject(), styleName);

    return this.cacheManager.set(
      styleName,
      {
        ...parsedSheet,
        ...nativeSheet.classNames,
      } as SheetMap<ParsedBlock>,
      options,
    );
  }

  /**
   * Compose and extend multiple style sheets to create 1 style sheet.
   */
  extendStyles(...styleSheets: StyleSheetFactory<Theme, any>[]): StyleSheetFactory<Theme, any> {
    return (theme: Theme) => {
      const sheets = styleSheets.map(sheet => sheet(theme));

      return deepMerge(true, {}, ...sheets);
    };
  }

  /**
   * Flush a target component's transformed styles and inject them into the DOM.
   * If no target defined, will flush all buffered styles.
   */
  flushStyles(styleName?: StyleName) {}

  /**
   * Return true if the style object is a parsed block and not a native block.
   */
  isParsedBlock(block: NativeBlock | ParsedBlock): block is ParsedBlock {
    return isObject(block);
  }

  /**
   * Parse an Aesthetic style sheet into an adapter native style sheet.
   */
  parseStyleSheet(styleSheet: SheetMap<NativeBlock>, styleName: StyleName): SheetMap<ParsedBlock> {
    // @ts-ignore Allow spread
    return { ...styleSheet };
  }

  /**
   * Purge and remove all styles from the DOM for the target component.
   * If no target defined, will purge all possible styles.
   */
  purgeStyles(styleName?: StyleName) {}

  /**
   * Return a native style sheet manager used for injecting CSS.
   */
  protected getStyleSheetManager(): StyleSheetManager {
    if (this.sheetManager) {
      return this.sheetManager;
    }

    this.sheetManager = new StyleSheetManager();

    return this.sheetManager;
  }
}
